Notebook Document Synchronization

Notebooks are becoming more and more popular. Adding support for them to the
language server protocol allows notebook editors to reuse language smarts
provided by the server inside a notebook or a notebook cell, respectively. To
reuse protocol parts and therefore server implementations notebooks are
modeled in the following way in LSP:

* notebook document: a collection of notebook cells typically stored in a file on
 disk. A notebook document has a type and can be uniquely identified using a
 resource URI.
* notebook cell: holds the actual text content. Cells have a kind (either code or
 markdown). The actual text content of the cell is stored in a text document
 which can be synced to the server like all other text documents. Cell text
 documents have an URI however servers should not rely on any format for this
 URI since it is up to the client on how it will create these URIs. The URIs must
 be unique across ALL notebook cells and can therefore be used to uniquely
 identify a notebook cell or the cell’s text document.

The two concepts are defined as follows:

/**
 * A notebook document.
 *
 * @since 3.17.0
 */
export interface NotebookDocument {

	/**
	 * The notebook document's URI.
	 */
	uri: URI;

	/**
	 * The type of the notebook.
	 */
	notebookType: string;

	/**
	 * The version number of this document (it will increase after each
	 * change, including undo/redo).
	 */
	version: integer;

	/**
	 * Additional metadata stored with the notebook
	 * document.
	 */
	metadata?: LSPObject;

	/**
	 * The cells of a notebook.
	 */
	cells: NotebookCell[];
}
/**
 * A notebook cell.
 *
 * A cell's document URI must be unique across ALL notebook
 * cells and can therefore be used to uniquely identify a
 * notebook cell or the cell's text document.
 *
 * @since 3.17.0
 */
export interface NotebookCell {

	/**
	 * The cell's kind
	 */
	kind: NotebookCellKind;

	/**
	 * The URI of the cell's text document
	 * content.
	 */
	document: DocumentUri;

	/**
	 * Additional metadata stored with the cell.
	 */
	metadata?: LSPObject;

	/**
	 * Additional execution summary information
	 * if supported by the client.
	 */
	executionSummary?: ExecutionSummary;
}
/**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */
export namespace NotebookCellKind {

	/**
	 * A markup-cell is formatted source that is used for display.
	 */
	export const Markup: 1 = 1;

	/**
	 * A code-cell is source code.
	 */
	export const Code: 2 = 2;
}
export interface ExecutionSummary {
	/**
	 * A strict monotonically increasing value
	 * indicating the execution order of a cell
	 * inside a notebook.
	 */
	executionOrder: uinteger;

	/**
	 * Whether the execution was successful or
	 * not if known by the client.
	 */
	success?: boolean;
}

Next we describe how notebooks, notebook cells and the content of a notebook
cell should be synchronized to a language server.

Syncing the text content of a cell is relatively easy since clients should model
them as text documents. However since the URI of a notebook cell’s text
document should be opaque, servers can not know its scheme nor its path.
However what is know is the notebook document itself. We therefore introduce
a special filter for notebook cell documents:

/**
 * A notebook cell text document filter denotes a cell text
 * document by different properties.
 *
 * @since 3.17.0
 */
export interface NotebookCellTextDocumentFilter {
	/**
	 * A filter that matches against the notebook
	 * containing the notebook cell. If a string
	 * value is provided it matches against the
	 * notebook type. '*' matches every notebook.
	 */
	notebook: string | NotebookDocumentFilter;

	/**
	 * A language id like `python`.
	 *
	 * Will be matched against the language id of the
	 * notebook cell document. '*' matches every language.
	 */
	language?: string;
}
/**
 * A notebook document filter denotes a notebook document by
 * different properties.
 *
 * @since 3.17.0
 */
export type NotebookDocumentFilter = {
	/** The type of the enclosing notebook. */
	notebookType: string;

	/** A Uri scheme, like `file` or `untitled`. */
	scheme?: string;

	/** A glob pattern. */
	pattern?: string;
} | {
	/** The type of the enclosing notebook. */
	notebookType?: string;

	/** A Uri scheme, like `file` or `untitled`.*/
	scheme: string;

	/** A glob pattern. */
	pattern?: string;
} | {
	/** The type of the enclosing notebook. */
	notebookType?: string;

	/** A Uri scheme, like `file` or `untitled`. */
	scheme?: string;

	/** A glob pattern. */
	pattern: string;
};

Given these structures a Python cell document in a Jupyter notebook stored on
disk in a folder having books1 in its path can be identified as follows;

{
	notebook: {
		scheme: 'file',
		pattern '**/books1/**',
		notebookType: 'jupyter-notebook'
	},
	language: 'python'
}

A NotebookCellTextDocumentFilter can be used to register providers for
certain requests like code complete or hover. If such a provider is registered the
client will send the corresponding textDocument/* requests to the server using
the cell text document’s URI as the document URI.

There are cases where simply only knowing about a cell’s text content is not
enough for a server to reason about the cells content and to provide good
language smarts. Sometimes it is necessary to know all cells of a notebook
document including the notebook document itself. Consider a notebook that has
two JavaScript cells with the following content

Cell one:

function add(a, b) {
	return a + b;
}

Cell two:

add/*<cursor>*/;

Requesting code assist in cell two at the marked cursor position should propose
the function add which is only possible if the server knows about cell one and
cell two and knows that they belong to the same notebook document.

The protocol will therefore support two modes when it comes to synchronizing
cell text content:

* cellContent: in this mode only the cell text content is synchronized to the
 server using the standard textDocument/did* notification. No notebook
 document and no cell structure is synchronized. This mode allows for easy
 adoption of notebooks since servers can reuse most of it implementation logic.
* notebook: in this mode the notebook document, the notebook cells and the
 notebook cell text content is synchronized to the server. To allow servers to
 create a consistent picture of a notebook document the cell text content is
 NOT synchronized using the standard textDocument/did* notifications. It is
 instead synchronized using special notebookDocument/did* notifications.
 This ensures that the cell and its text content arrives on the server using one
 open, change or close event.

In both modes, notebook cell text documents are treated as regular text
documents. They are always synchronized using incremental sync.

To request the cell content only a normal document selector can be used. For
example the selector [{ language: 'python' }] will synchronize Python
notebook document cells to the server. However since this might synchronize
unwanted documents as well a document filter can also be a
NotebookCellTextDocumentFilter. So { notebook: { scheme: 'file',
notebookType: 'jupyter-notebook' }, language: 'python' }
synchronizes all Python cells in a Jupyter notebook stored on disk.

To synchronize the whole notebook document a server provides a
notebookDocumentSync in its server capabilities. For example:

{
	notebookDocumentSync: {
		notebookSelector: [
			{
				notebook: { scheme: 'file', notebookType: 'jupyter-notebook' },
				cells: [{ language: 'python' }]
			}
		]
	}
}

Synchronizes the notebook including all Python cells to the server if the
notebook is stored on disk.

Client Capability:

The following client capabilities are defined for notebook documents:

* property name (optional): notebookDocument.synchronization 
* property type: NotebookDocumentSyncClientCapabilities defined as
 follows

/**
 * Notebook specific client capabilities.
 *
 * @since 3.17.0
 */
export interface NotebookDocumentSyncClientCapabilities {

	/**
	 * Whether implementation supports dynamic registration. If this is
	 * set to `true` the client supports the new
	 * `(NotebookDocumentSyncRegistrationOptions & NotebookDocumentSyncOptions)`
	 * return value for the corresponding server capability as well.
	 */
	dynamicRegistration?: boolean;

	/**
	 * The client supports sending execution summary data per cell.
	 */
	executionSummarySupport?: boolean;
}

Server Capability:

The following server capabilities are defined for notebook documents:

* property name (optional): notebookDocumentSync 
* property type: NotebookDocumentSyncOptions |
 NotebookDocumentSyncRegistrationOptions where
 NotebookDocumentOptions is defined as follows:

/**
 * Options specific to a notebook plus its cells
 * to be synced to the server.
 *
 * If a selector provides a notebook document
 * filter but no cell selector all cells of a
 * matching notebook document will be synced.
 *
 * If a selector provides no notebook document
 * filter but only a cell selector all notebook
 * documents that contain at least one matching
 * cell will be synced.
 *
 * @since 3.17.0
 */
export interface NotebookDocumentSyncOptions {
	/**
	 * The notebooks to be synced
	 */
	notebookSelector: ({
		/**
		 * The notebook to be synced. If a string
		 * value is provided it matches against the
		 * notebook type. '*' matches every notebook.
		 */
		notebook: string | NotebookDocumentFilter;

		/**
		 * The cells of the matching notebook to be synced.
		 */
		cells?: { language: string }[];
	} | {
		/**
		 * The notebook to be synced. If a string
		 * value is provided it matches against the
		 * notebook type. '*' matches every notebook.
		 */
		notebook?: string | NotebookDocumentFilter;

		/**
		 * The cells of the matching notebook to be synced.
		 */
		cells: { language: string }[];
	})[];

	/**
	 * Whether save notification should be forwarded to
	 * the server. Will only be honored if mode === `notebook`.
	 */
	save?: boolean;
}

Registration Options: notebookDocumentSyncRegistrationOptions defined as
follows:

/**
 * Registration options specific to a notebook.
 *
 * @since 3.17.0
 */
export interface NotebookDocumentSyncRegistrationOptions extends
	NotebookDocumentSyncOptions, StaticRegistrationOptions {
}

