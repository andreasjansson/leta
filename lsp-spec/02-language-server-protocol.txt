Language Server Protocol

The language server protocol defines a set of JSON-RPC request, response and
notification messages which are exchanged using the above base protocol. This
section starts describing the basic JSON structures used in the protocol. The
document uses TypeScript interfaces in strict mode to describe these. This
means for example that a null value has to be explicitly listed and that a
mandatory property must be listed even if a falsy value might exist. Based on the
basic JSON structures, the actual requests with their responses and the
notifications are described.

An example would be a request sent from the client to the server to request a
hover value for a symbol at a certain position in a text document. The request’s
method would be textDocument/hover with a parameter like this:

interface HoverParams {
	textDocument: string; /** The text document's URI in string form */
	position: { line: uinteger; character: uinteger; };
}

The result of the request would be the hover to be presented. In its simple form
it can be a string. So the result looks like this:

interface HoverResult {
	value: string;
}

Please also note that a response return value of null indicates no result. It
doesn’t tell the client to resend the request.

In general, the language server protocol supports JSON-RPC messages, however
the base protocol defined here uses a convention such that the parameters
passed to request/notification messages should be of object type (if passed at
all). However, this does not disallow using Array parameter types in custom
messages.

The protocol currently assumes that one server serves one tool. There is
currently no support in the protocol to share one server between different tools.
Such sharing would require additional protocol e.g. to lock a document to
support concurrent editing.

Capabilities

Not every language server can support all features defined by the protocol. LSP
therefore provides ‘capabilities’. A capability groups a set of language features. A
development tool and the language server announce their supported features
using capabilities. As an example, a server announces that it can handle the
textDocument/hover request, but it might not handle the workspace/symbol
request. Similarly, a development tool announces its ability to provide about to
save notifications before a document is saved, so that a server can compute
textual edits to format the edited document before it is saved.

The set of capabilities is exchanged between the client and server during the
initialize request.

Request, Notification and Response Ordering

Responses to requests should be sent in roughly the same order as the requests
appear on the server or client side. So for example if a server receives a
textDocument/completion request and then a textDocument/signatureHelp
request it will usually first return the response for the
textDocument/completion and then the response for
textDocument/signatureHelp.

However, the server may decide to use a parallel execution strategy and may
wish to return responses in a different order than the requests were received.
The server may do so as long as this reordering doesn’t affect the correctness of
the responses. For example, reordering the result of textDocument/completion
and textDocument/signatureHelp is allowed, as each of these requests
usually won’t affect the output of the other. On the other hand, the server most
likely should not reorder textDocument/definition and
textDocument/rename requests, since executing the latter may affect the result
of the former.

Message Documentation

As said LSP defines a set of requests, responses and notifications. Each of those
are documented using the following format:

* a header describing the request
* an optional Client capability section describing the client capability of the
 request. This includes the client capabilities property path and JSON structure.
* an optional Server Capability section describing the server capability of the
 request. This includes the server capabilities property path and JSON
 structure. Clients should ignore server capabilities they don’t understand (e.g.
 the initialize request shouldn’t fail in this case).
* an optional Registration Options section describing the registration option if
 the request or notification supports dynamic capability registration. See the
 register and unregister request for how this works in detail.
* a Request section describing the format of the request sent. The method is a
 string identifying the request, the params are documented using a TypeScript
 interface. It is also documented whether the request supports work done
 progress and partial result progress.
* a Response section describing the format of the response. The result item
 describes the returned data in case of a success. The optional partial result item
 describes the returned data of a partial result notification. The error.data
 describes the returned data in case of an error. Please remember that in case
 of a failure the response already contains an error.code and an error.message
 field. These fields are only specified if the protocol forces the use of certain
 error codes or messages. In cases where the server can decide on these
 values freely they aren’t listed here.

